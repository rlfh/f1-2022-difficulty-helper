"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseQueryParams = exports.isCustomUrl = exports.doesRequestPathMatchLegacyRoute = exports.doesRequestPathMatchRoute = void 0;
const chalk_1 = __importDefault(require("chalk"));
const core_1 = require("../../core");
const constants_1 = require("../../core/constants");
const glob_1 = require("../../core/utils/glob");
const routes_1 = require("./rules/routes");
function doesRequestPathMatchRoute(requestPath, routeRule, requestMethod, methods, authStatus) {
    var _a;
    core_1.logger.silly(`check if request match route`);
    const route = routeRule === null || routeRule === void 0 ? void 0 : routeRule.route;
    const hasRouteRuleHasWildcard = route === null || route === void 0 ? void 0 : route.includes("*");
    core_1.logger.silly(` - route: ${chalk_1.default.yellow(route)}`);
    core_1.logger.silly(` - wildcard: ${chalk_1.default.yellow(hasRouteRuleHasWildcard)}`);
    // Do not match auth requests besides /.auth/login/<idp>
    // /.auth/login/<idp> must match a non wildcard rule
    // no allowed role can be listed for a rule with route /.auth/login/<idp>
    if ((authStatus != constants_1.AUTH_STATUS.NoAuth && authStatus != constants_1.AUTH_STATUS.HostNameAuthLogin) ||
        (authStatus == constants_1.AUTH_STATUS.HostNameAuthLogin && (hasRouteRuleHasWildcard || ((_a = routeRule === null || routeRule === void 0 ? void 0 : routeRule.allowedRoles) === null || _a === void 0 ? void 0 : _a.length)))) {
        core_1.logger.silly(` - authStatus: ${chalk_1.default.yellow(authStatus)}`);
        core_1.logger.silly(` - allowedRoles: ${chalk_1.default.yellow(routeRule === null || routeRule === void 0 ? void 0 : routeRule.allowedRoles)}`);
        core_1.logger.silly(` - match: ${chalk_1.default.yellow(false)}`);
        return false;
    }
    // request method must match allowed methods if listed
    if (methods != null && !methods.includes(requestMethod)) {
        core_1.logger.silly(` - methods: ${chalk_1.default.yellow(methods)}`);
        core_1.logger.silly(` - requestMethod: ${chalk_1.default.yellow(requestMethod)}`);
        core_1.logger.silly(` - match: ${chalk_1.default.yellow(false)}`);
        return false;
    }
    if (route === requestPath || (hasRouteRuleHasWildcard && doesRequestPathMatchWildcardRoute(requestPath, route))) {
        core_1.logger.silly(` - doesRequestPathMatchWildcardRoute: ${chalk_1.default.yellow(true)}`);
        return true;
    }
    // Since this is a file request, return now, since we are trying to get a match by appending /index.html doesn't apply here
    if (!route) {
        core_1.logger.silly(` - route: ${chalk_1.default.yellow(route || "<empty>")}`);
        core_1.logger.silly(` - match: ${chalk_1.default.yellow(false)}`);
        return false;
    }
    // If the request hasn't already matched the route, and the request is a non-file path,
    // try adding /index.html to the path to see if it then matches. This is especially handy
    // to match a request to the /{customPath}/* route
    const alternateRequestPath = (0, routes_1.getIndexHtml)(requestPath);
    core_1.logger.silly(` - alternateRequestPath: ${chalk_1.default.yellow(alternateRequestPath)}`);
    return ((routeRule === null || routeRule === void 0 ? void 0 : routeRule.route) === alternateRequestPath ||
        (hasRouteRuleHasWildcard && doesRequestPathMatchWildcardRoute(alternateRequestPath, routeRule === null || routeRule === void 0 ? void 0 : routeRule.route)));
}
exports.doesRequestPathMatchRoute = doesRequestPathMatchRoute;
function doesRequestPathMatchLegacyRoute(requestPath, routeRule, isAuthRequest, isFileRequest) {
    const hasWildcard = routeRule === null || routeRule === void 0 ? void 0 : routeRule.route.includes("*");
    if ((routeRule === null || routeRule === void 0 ? void 0 : routeRule.route) === requestPath || (!isAuthRequest && hasWildcard)) {
        return true;
    }
    // since this is a file request, don't perform the wildcard matching check
    if (isFileRequest) {
        return false;
    }
    // if the request hasn't already matched the route, and the request is a non-file path,
    // try adding /index.html to the path to see if it then matches. This is especially handy
    // to match a request to the /{customPath}/* route
    const alternateRequestPath = (0, routes_1.getIndexHtml)(requestPath);
    return (routeRule === null || routeRule === void 0 ? void 0 : routeRule.route) === alternateRequestPath || (!isAuthRequest && hasWildcard);
}
exports.doesRequestPathMatchLegacyRoute = doesRequestPathMatchLegacyRoute;
function doesRequestPathMatchWildcardRoute(requestPath, requestPathFileWithWildcard) {
    core_1.logger.silly(`checking wildcard route`);
    core_1.logger.silly(` - glob: ${chalk_1.default.yellow(requestPathFileWithWildcard)}`);
    const pathBeforeWildcard = requestPathFileWithWildcard === null || requestPathFileWithWildcard === void 0 ? void 0 : requestPathFileWithWildcard.substr(0, requestPathFileWithWildcard === null || requestPathFileWithWildcard === void 0 ? void 0 : requestPathFileWithWildcard.indexOf("*"));
    core_1.logger.silly(` - pathBeforeWildcard: ${chalk_1.default.yellow(pathBeforeWildcard || "<empty>")}`);
    // before processing regexp which might be expensive
    // let's check first if both path and rule start with the same substring
    if (pathBeforeWildcard && requestPath.startsWith(pathBeforeWildcard) === false) {
        core_1.logger.silly(` - base path doesn't match. Exit`);
        return false;
    }
    // also, let's check if the route rule doesn't contains a wildcard in the middle of the path
    if ((0, glob_1.isValidGlobExpression)(requestPathFileWithWildcard) === false) {
        core_1.logger.silly(` - route rule contains a wildcard in the middle of the path. Exit`);
        return false;
    }
    // we don't support full globs in the config file.
    // add this little utility to convert a wildcard into a valid glob pattern
    const regexp = new RegExp(`^${(0, glob_1.globToRegExp)(requestPathFileWithWildcard)}$`);
    core_1.logger.silly(` - regexp: ${chalk_1.default.yellow(regexp)}`);
    const isMatch = regexp.test(requestPath);
    core_1.logger.silly(` - isMatch: ${chalk_1.default.yellow(isMatch)}`);
    return isMatch;
}
function isCustomUrl(req) {
    var _a;
    return !!((_a = req.url) === null || _a === void 0 ? void 0 : _a.startsWith(constants_1.CUSTOM_URL_SCHEME));
}
exports.isCustomUrl = isCustomUrl;
function parseQueryParams(req, matchingRouteRule) {
    var _a;
    const urlPathnameWithQueryParams = (matchingRouteRule === null || matchingRouteRule === void 0 ? void 0 : matchingRouteRule.rewrite) || req.url;
    const url = new URL(urlPathnameWithQueryParams, `${constants_1.SWA_CLI_APP_PROTOCOL}://${(_a = req === null || req === void 0 ? void 0 : req.headers) === null || _a === void 0 ? void 0 : _a.host}`);
    const urlQueryString = url.searchParams.toString();
    const urlPathnameWithoutQueryParams = url.pathname;
    if (urlQueryString !== "") {
        core_1.logger.silly(` - url: ${chalk_1.default.yellow(url)}`);
        core_1.logger.silly(` - urlQueryString: ${chalk_1.default.yellow(urlQueryString)}`);
        url.searchParams.forEach((value, key) => {
            core_1.logger.silly(`   - ${key}: ${chalk_1.default.yellow(value || "<undefined>")}`);
        });
        core_1.logger.silly(` - urlPathnameWithQueryParams: ${chalk_1.default.yellow(urlPathnameWithQueryParams)}`);
        core_1.logger.silly(` - urlPathnameWithoutQueryParams: ${chalk_1.default.yellow(urlPathnameWithoutQueryParams)}`);
    }
    return {
        url,
        urlPathnameWithoutQueryParams,
        urlPathnameWithQueryParams,
    };
}
exports.parseQueryParams = parseQueryParams;
//# sourceMappingURL=route-processor.js.map