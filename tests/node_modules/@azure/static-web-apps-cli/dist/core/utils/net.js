"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isValidIpAddress = exports.hostnameToIpAdress = exports.parsePort = exports.response = exports.address = exports.parseUrl = exports.validateDevServerConfig = exports.isHttpUrl = exports.askNewPort = exports.isAcceptingTcpConnections = void 0;
const chalk_1 = __importDefault(require("chalk"));
const get_port_1 = __importDefault(require("get-port"));
const net_1 = __importDefault(require("net"));
const ora_1 = __importDefault(require("ora"));
const wait_on_1 = __importDefault(require("wait-on"));
const prompts_1 = require("../prompts");
const logger_1 = require("./logger");
const VALID_PORT_MIN = 1024;
const VALID_PORT_MAX = 65535;
/**
 * Check if a given remote address and port are accepting TCP connections.
 * @param Object host and port of the server to check.
 * @returns The resolved port number if the given server does not accept TCP connections. 0 if the port is already taken.
 */
async function isAcceptingTcpConnections({ host, port }) {
    port = Number(port);
    logger_1.logger.silly(`Checking if ${host}:${port} is accepting TCP connections...`);
    // Check if current port is beyond the MAX valid port range
    if (port > VALID_PORT_MAX) {
        logger_1.logger.silly(`Port ${port} is beyond the valid port range (${VALID_PORT_MAX}).`);
        return 0;
    }
    return new Promise((resolve) => {
        const socket = net_1.default.createConnection(port, host);
        socket
            .once("error", () => {
            socket.end();
            resolve(port);
        })
            .once("connect", async () => {
            resolve(0);
            socket.end();
        });
    });
}
exports.isAcceptingTcpConnections = isAcceptingTcpConnections;
/**
 * Ask if the user wants to use a new port number, and if yes return the new port number.
 * @returns A new port number if the user accepts or 0 if he refuses.
 */
async function askNewPort() {
    const confirm = await (0, prompts_1.confirmChooseRandomPort)(true);
    return confirm ? (0, get_port_1.default)() : 0;
}
exports.askNewPort = askNewPort;
/**
 * Check if a given URL string is a valid URL.
 * @param url The URL string to check.
 * @returns True if the URL string is a valid URL. False otherwise.
 */
function isHttpUrl(url) {
    if (!url) {
        return false;
    }
    try {
        const uri = new URL(url);
        return uri.protocol.startsWith("http") || uri.protocol.startsWith("ws");
    }
    catch {
        return false;
    }
}
exports.isHttpUrl = isHttpUrl;
/**
 * Checks if a given server is up and accepting connection.
 * @param url An HTTP URL.
 * @param timeout Maximum time in ms to wait before exiting with failure (1) code,
  default Infinity.
 */
async function validateDevServerConfig(url, timeout) {
    logger_1.logger.silly(`Validating dev server config:`);
    logger_1.logger.silly({
        url,
        timeout,
    });
    let { hostname, port } = parseUrl(url);
    try {
        const resolvedPortNumber = await isAcceptingTcpConnections({ port, host: hostname });
        if (resolvedPortNumber !== 0) {
            const spinner = (0, ora_1.default)();
            try {
                spinner.start(`Waiting for ${chalk_1.default.green(url)} to be ready`);
                await (0, wait_on_1.default)({
                    resources: [`tcp:${hostname}:${port}`],
                    delay: 1000,
                    interval: 100,
                    simultaneous: 1,
                    timeout: timeout ? timeout * 1000 : timeout,
                    tcpTimeout: 1000,
                    window: 1000,
                    strictSSL: false,
                    verbose: false, // force disable verbose logs even if SWA_CLI_DEBUG is enabled
                });
                spinner.succeed(`Connected to ${chalk_1.default.green(url)} successfully`);
                spinner.clear();
            }
            catch (err) {
                spinner.fail();
                logger_1.logger.error(`Could not connect to "${url}". Is the server up and running?`, true);
            }
        }
    }
    catch (err) {
        if (err.message.includes("EACCES")) {
            logger_1.logger.error(`Port "${port}" cannot be used. You might need elevated or admin privileges. Or, use a valid port from ${VALID_PORT_MIN} to ${VALID_PORT_MAX}.`, true);
        }
        else {
            logger_1.logger.error(err.message, true);
        }
    }
}
exports.validateDevServerConfig = validateDevServerConfig;
/**
 * Parse a given URL and return its protocol, port, host and hostname.
 * @param url The URL string to check.
 * @returns Protocol, port, host and hostname extracted from the URL.
 */
function parseUrl(url) {
    if (!url) {
        throw new Error(`Address: ${url} is malformed!`);
    }
    const { protocol, port, host, hostname } = new URL(url);
    return {
        protocol,
        port: Number(port),
        host,
        hostname,
    };
}
exports.parseUrl = parseUrl;
/**
 * Construct a valid URL string from a host, port and protocol.
 * @param host A host address.
 * @param port (optional) A host port.
 * @param protocol (optional) A host protocol.
 * @throws {Error} if the URL is malformed.
 * @returns
 */
function address(host, port = 80, protocol = `http`) {
    if (!host) {
        throw new Error(`Host value is not set`);
    }
    let url = port === 80 ? `${protocol}://${host}` : `${protocol}://${host}:${port}`;
    if (isHttpUrl(url)) {
        return url;
    }
    else {
        throw new Error(`Address: ${url} is malformed!`);
    }
}
exports.address = address;
function response({ status, headers, cookies, body = "" }) {
    if (typeof status !== "number") {
        throw Error("TypeError: status code must be a number.");
    }
    body = body || null;
    const res = {
        status,
        cookies,
        headers: {
            status,
            "Content-Type": "application/json",
            ...headers,
        },
        body,
    };
    return res;
}
exports.response = response;
function parsePort(port) {
    const portNumber = parseInt(port, 10);
    if (isNaN(portNumber)) {
        logger_1.logger.error(`Port "${port}" is not a number.`, true);
    }
    else {
        if (portNumber < VALID_PORT_MIN || portNumber > VALID_PORT_MAX) {
            logger_1.logger.error(`Port "${port}" is out of range. Valid ports are from ${VALID_PORT_MIN} to ${VALID_PORT_MAX}.`, true);
        }
    }
    return portNumber;
}
exports.parsePort = parsePort;
function hostnameToIpAdress(hostnameOrIpAddress) {
    if (hostnameOrIpAddress === "localhost") {
        return "127.0.0.1";
    }
    return hostnameOrIpAddress;
}
exports.hostnameToIpAdress = hostnameToIpAdress;
function isValidIpAddress(ip) {
    return net_1.default.isIP(ip);
}
exports.isValidIpAddress = isValidIpAddress;
//# sourceMappingURL=net.js.map