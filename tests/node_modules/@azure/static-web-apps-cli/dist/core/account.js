"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getStaticSiteDeployment = exports.listStaticSites = exports.listSubscriptions = exports.listResourceGroups = exports.listTenants = exports.chooseOrCreateProjectDetails = exports.authenticateWithAzureIdentity = void 0;
const arm_appservice_1 = require("@azure/arm-appservice");
const arm_resources_1 = require("@azure/arm-resources");
const arm_subscriptions_1 = require("@azure/arm-subscriptions");
const identity_1 = require("@azure/identity");
const chalk_1 = __importDefault(require("chalk"));
const ora_1 = __importDefault(require("ora"));
const path_1 = __importDefault(require("path"));
const env_1 = require("./env");
const prompts_1 = require("./prompts");
const swa_cli_persistence_plugin_1 = require("./swa-cli-persistence-plugin");
const persistence_cache_plugin_1 = require("./swa-cli-persistence-plugin/persistence-cache-plugin");
const utils_1 = require("./utils");
const docker_1 = require("./utils/docker");
const DEFAULT_AZURE_LOCATION = "West US 2";
async function authenticateWithAzureIdentity(details = {}, useKeychain = true, clearCache = false) {
    utils_1.logger.silly("Executing authenticateWithAzureIdentity");
    utils_1.logger.silly({ details, useKeychain });
    let tokenCachePersistenceOptions = {
        enabled: false,
        name: "swa-cli-persistence-plugin",
        unsafeAllowUnencryptedStorage: false,
    };
    if (useKeychain === true) {
        utils_1.logger.silly("Keychain is enabled");
        (0, identity_1.useIdentityPlugin)(swa_cli_persistence_plugin_1.swaCliPersistencePlugin);
        tokenCachePersistenceOptions.enabled = true;
        if (clearCache) {
            utils_1.logger.silly("Clearing keychain credentials");
            await new persistence_cache_plugin_1.SWACLIPersistenceCachePlugin(tokenCachePersistenceOptions).clearCache();
        }
    }
    else {
        utils_1.logger.silly("Keychain is disabled");
        tokenCachePersistenceOptions.enabled = false;
    }
    const browserCredential = new identity_1.InteractiveBrowserCredential({
        redirectUri: `http://localhost:31337`,
        tokenCachePersistenceOptions,
        tenantId: details.tenantId,
    });
    const deviceCredential = new identity_1.DeviceCodeCredential({
        tokenCachePersistenceOptions,
        tenantId: details.tenantId,
    });
    const environmentCredential = new identity_1.EnvironmentCredential();
    // Only use interactive browser credential if we're not running in docker
    const credentials = (0, docker_1.isRunningInDocker)() ? [environmentCredential, deviceCredential] : [environmentCredential, browserCredential, deviceCredential];
    if (details.tenantId && details.clientId && details.clientSecret) {
        const clientSecretCredential = new identity_1.ClientSecretCredential(details.tenantId, details.clientId, details.clientSecret, {
            tokenCachePersistenceOptions,
        });
        // insert at the beginning of the array to ensure that it is tried first
        credentials.unshift(clientSecretCredential);
    }
    return new identity_1.ChainedTokenCredential(...credentials);
}
exports.authenticateWithAzureIdentity = authenticateWithAzureIdentity;
async function isResourceGroupExists(resourceGroupName, subscriptionId, credentialChain) {
    var _a;
    const client = new arm_resources_1.ResourceManagementClient(credentialChain, subscriptionId);
    try {
        const rg = await client.resourceGroups.checkExistence(resourceGroupName);
        return rg.body;
    }
    catch (error) {
        if ((_a = error === null || error === void 0 ? void 0 : error.code) === null || _a === void 0 ? void 0 : _a.includes("ResourceGroupNotFound")) {
            return false;
        }
        throw new Error(error);
    }
}
async function createResourceGroup(resourcGroupeName, credentialChain, subscriptionId) {
    const client = new arm_resources_1.ResourceManagementClient(credentialChain, subscriptionId);
    const { AZURE_REGION_LOCATION } = (0, env_1.swaCLIEnv)();
    const resourceGroupEnvelope = {
        location: AZURE_REGION_LOCATION || DEFAULT_AZURE_LOCATION,
    };
    const result = await client.resourceGroups.createOrUpdate(resourcGroupeName, resourceGroupEnvelope);
    utils_1.logger.silly(result);
    return result;
}
async function gracefullyFail(promise, errorCode) {
    try {
        return await promise;
    }
    catch (error) {
        if (errorCode === undefined || (error.statusCode && errorCode === error.statusCode)) {
            utils_1.logger.silly(`Caught error: ${error.message}`);
            return undefined;
        }
        throw error;
    }
}
async function createStaticSite(options, credentialChain, subscriptionId) {
    let { appName, resourceGroupName } = options;
    const maxProjectNameLength = 63; // azure convention is 64 characters (zero-indexed)
    const defaultStaticSiteName = appName || (0, utils_1.dasherize)(path_1.default.basename(process.cwd())).substring(0, maxProjectNameLength);
    appName = await (0, prompts_1.chooseProjectName)(defaultStaticSiteName, maxProjectNameLength);
    resourceGroupName = resourceGroupName || `${appName}-rg`;
    let spinner = (0, ora_1.default)("Creating a new project...").start();
    // if the resource group does not exist, create it
    if ((await isResourceGroupExists(resourceGroupName, subscriptionId, credentialChain)) === false) {
        utils_1.logger.silly(`Resource group "${resourceGroupName}" does not exist. Creating one...`);
        // create the resource group
        await createResourceGroup(resourceGroupName, credentialChain, subscriptionId);
    }
    // create the static web app instance
    try {
        const websiteClient = new arm_appservice_1.WebSiteManagementClient(credentialChain, subscriptionId);
        const { AZURE_REGION_LOCATION } = (0, env_1.swaCLIEnv)();
        const staticSiteEnvelope = {
            location: AZURE_REGION_LOCATION || DEFAULT_AZURE_LOCATION,
            sku: { name: "Free", tier: "Free" },
            // these are mandatory, otherwise the static site will not be created
            buildProperties: {
                appLocation: "",
                outputLocation: "",
                apiLocation: "",
            },
        };
        utils_1.logger.silly(`Checking if project "${appName}" already exists...`);
        // check if the static site already exists
        const project = await gracefullyFail(websiteClient.staticSites.getStaticSite(resourceGroupName, appName), 404);
        const projectExists = project !== undefined;
        if (projectExists) {
            spinner.stop();
            const confirm = await (prompts_1.wouldYouLikeToOverrideStaticSite === null || prompts_1.wouldYouLikeToOverrideStaticSite === void 0 ? void 0 : (0, prompts_1.wouldYouLikeToOverrideStaticSite)(appName));
            if (confirm === false) {
                return (await chooseOrCreateStaticSite(options, credentialChain, subscriptionId));
            }
        }
        if (projectExists) {
            spinner.start(`Updating project "${appName}"...`);
        }
        utils_1.logger.silly(`Creating static site "${appName}" in resource group "${resourceGroupName}"...`);
        const result = await websiteClient.staticSites.beginCreateOrUpdateStaticSiteAndWait(resourceGroupName, appName, staticSiteEnvelope);
        utils_1.logger.silly(`Static site "${appName}" created successfully.`);
        utils_1.logger.silly(result);
        if (result.id) {
            if (projectExists) {
                spinner.succeed(`Project "${appName}" updated successfully.`);
            }
            else {
                spinner.succeed(chalk_1.default.green("Project created successfully!"));
            }
        }
        return result;
    }
    catch (error) {
        spinner.fail(chalk_1.default.red("Project creation failed."));
        utils_1.logger.error(error.message, true);
        return undefined;
    }
}
async function chooseOrCreateStaticSite(options, credentialChain, subscriptionId) {
    const staticSites = await listStaticSites(credentialChain, subscriptionId);
    // 1- when there are no static sites
    if (staticSites.length === 0) {
        const confirm = await (0, prompts_1.wouldYouLikeToCreateStaticSite)();
        if (confirm) {
            return (await createStaticSite(options, credentialChain, subscriptionId));
        }
        else {
            utils_1.logger.error("No projects found. Create a new project and try again.", true);
        }
    }
    // 2- when there is only one static site
    else if (staticSites.length === 1) {
        utils_1.logger.silly("Only one project found. Trying to use it if the name matches...");
        const staticSite = staticSites[0];
        if (options.appName === staticSite.name) {
            return staticSite;
        }
        else {
            // if the name doesn't match, ask the user if they want to create a new project
            const confirm = await (0, prompts_1.wouldYouLikeToCreateStaticSite)();
            if (confirm) {
                return (await createStaticSite(options, credentialChain, subscriptionId));
            }
            else {
                utils_1.logger.error(`The provided project name "${options.appName}" was not found.`, true);
            }
        }
    }
    // 3- when there are multiple static sites
    if (options.appName) {
        // if the user provided a project name, try to find it and use it
        utils_1.logger.silly(`Looking for project "${options.appName}"...`);
        const staticSite = staticSites.find((s) => s.name === options.appName);
        if (staticSite) {
            return staticSite;
        }
    }
    // otherwise, ask the user to choose one
    const staticSite = await (0, prompts_1.chooseStaticSite)(staticSites, options.appName);
    if (staticSite === "NEW") {
        // if the user chose to create a new project, switch to the create project flow
        return (await createStaticSite(options, credentialChain, subscriptionId));
    }
    return staticSites.find((s) => s.name === staticSite);
}
async function chooseOrCreateProjectDetails(options, credentialChain, subscriptionId, shouldPrintToken) {
    const staticSite = (await chooseOrCreateStaticSite(options, credentialChain, subscriptionId));
    utils_1.logger.silly("Static site found!");
    utils_1.logger.silly({ staticSite });
    if (staticSite && staticSite.id) {
        if (!shouldPrintToken && staticSite.provider !== "Custom" && staticSite.provider !== "None") {
            // TODO: add a temporary warning message until we ship `swa link/unlink`
            utils_1.logger.error(`The project "${staticSite.name}" is linked to "${staticSite.provider}"!`);
            utils_1.logger.error(`Unlink the project from the "${staticSite.provider}" provider and try again.`, true);
            return;
        }
        // in case we have a static site, we will use its resource group and name
        // get resource group name from static site id:
        //   /subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/swa-resource-groupe-name/providers/Microsoft.Web/sites/swa-static-site
        // 0 /      1      /                   2                /        3     /             4
        const resourceGroupName = staticSite.id.split("/")[4];
        const staticSiteName = staticSite.name;
        return {
            resourceGroupName,
            staticSiteName,
        };
    }
    else {
        utils_1.logger.error("No project found. Create a new project and try again.", true);
    }
    return;
}
exports.chooseOrCreateProjectDetails = chooseOrCreateProjectDetails;
async function listTenants(credentialChain) {
    const client = new arm_subscriptions_1.SubscriptionClient(credentialChain);
    const tenants = [];
    for await (let tenant of client.tenants.list()) {
        tenants.push(tenant);
    }
    return tenants;
}
exports.listTenants = listTenants;
async function listResourceGroups(credentialChain, subscriptionId) {
    const resourceGroups = [];
    const client = new arm_resources_1.ResourceManagementClient(credentialChain, subscriptionId);
    for await (let resource of client.resources.list()) {
        resourceGroups.push(resource);
    }
    return resourceGroups;
}
exports.listResourceGroups = listResourceGroups;
async function listSubscriptions(credentialChain) {
    const subscriptionClient = new arm_subscriptions_1.SubscriptionClient(credentialChain);
    const subscriptions = [];
    for await (let subscription of subscriptionClient.subscriptions.list()) {
        subscriptions.push(subscription);
    }
    return subscriptions;
}
exports.listSubscriptions = listSubscriptions;
async function listStaticSites(credentialChain, subscriptionId, resourceGroupName) {
    const staticSites = [];
    const websiteClient = new arm_appservice_1.WebSiteManagementClient(credentialChain, subscriptionId);
    let staticSiteList = websiteClient.staticSites.list();
    if (resourceGroupName) {
        staticSiteList = websiteClient.staticSites.listStaticSitesByResourceGroup(resourceGroupName);
    }
    for await (let staticSite of staticSiteList) {
        staticSites.push(staticSite);
    }
    return staticSites.sort((a, b) => { var _a; return (_a = a.name) === null || _a === void 0 ? void 0 : _a.localeCompare(b.name); });
}
exports.listStaticSites = listStaticSites;
async function getStaticSiteDeployment(credentialChain, subscriptionId, resourceGroupName, staticSiteName) {
    if (!subscriptionId) {
        utils_1.logger.error("An Azure subscription is required to access your deployment token.", true);
    }
    if (!resourceGroupName) {
        utils_1.logger.error("A resource group is required to access your deployment token.", true);
    }
    if (!staticSiteName) {
        utils_1.logger.error("A static site name is required to access your deployment token.", true);
    }
    const websiteClient = new arm_appservice_1.WebSiteManagementClient(credentialChain, subscriptionId);
    const deploymentTokenResponse = await websiteClient.staticSites.listStaticSiteSecrets(resourceGroupName, staticSiteName);
    return deploymentTokenResponse;
}
exports.getStaticSiteDeployment = getStaticSiteDeployment;
//# sourceMappingURL=account.js.map