"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.init = void 0;
const chalk_1 = __importDefault(require("chalk"));
const path_1 = __importDefault(require("path"));
const process_1 = __importDefault(require("process"));
const prompts_1 = require("../../core/prompts");
const utils_1 = require("../../core/utils");
const frameworks_1 = require("../../core/frameworks");
function registerCommand(program) {
    program
        .command("init [configName]")
        .usage("[configName] [options]")
        .description("initialize a new static web app project")
        .option("-y, --yes", "answer yes to all prompts (disable interactive mode)", false)
        .action(async (configName, _options, command) => {
        const options = await (0, utils_1.configureOptions)(undefined, command.optsWithGlobals(), command, "init", false);
        if (configName) {
            if ((0, utils_1.isUserOption)("configName")) {
                utils_1.logger.error(`swa init <configName> cannot be used when --config-name option is also set.`);
                utils_1.logger.error(`You either have to use the positional argument or option, not both at the same time.`, true);
            }
            options.configName = configName;
        }
        await init(options, !process_1.default.env.SWA_CLI_INTERNAL_COMMAND);
    });
}
exports.default = registerCommand;
async function init(options, showHints = true) {
    var _a, _b, _c;
    const configFilePath = options.config;
    const disablePrompts = (_a = options.yes) !== null && _a !== void 0 ? _a : false;
    const outputFolder = process_1.default.cwd();
    let configName = (_c = (_b = options.configName) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : "";
    if (configName === "") {
        const response = await (0, prompts_1.promptOrUseDefault)(disablePrompts, {
            type: "text",
            name: "configName",
            message: "Choose a configuration name:",
            initial: (0, utils_1.dasherize)(path_1.default.basename(outputFolder)),
            validate: (value) => value.trim() !== "" || "Configuration name cannot be empty",
            format: (value) => (0, utils_1.dasherize)(value.trim()),
        });
        configName = response.configName;
    }
    // TODO: start from template
    // if (isEmptyFolder(outputFolder)) {
    //   // Do you want to create a new project from a template?
    // }
    const detectedFolders = await (0, frameworks_1.detectProjectFolders)();
    let app = detectedFolders.app[0];
    let api = detectedFolders.api[0];
    if (detectedFolders.app.length > 1) {
        utils_1.logger.silly(`More than one (${detectedFolders.app.length}) app folders found`);
        const response = await (0, prompts_1.promptOrUseDefault)(disablePrompts, {
            type: "select",
            name: "app",
            message: "Which app folder do you want to use?",
            choices: detectedFolders.app.map((folder) => ({ title: folder.rootPath, value: folder })),
            initial: 0,
        });
        // Workaround for bug https://github.com/terkelg/prompts/issues/205
        app = typeof response.app === "number" ? detectedFolders.app[response.app] : response.app;
    }
    // Check if we can find api folders under selected app folder, and filter selection if we found some
    if (app !== undefined) {
        const childApiFolders = detectedFolders.api.filter((folder) => (0, frameworks_1.isDescendantPath)(folder.rootPath, app.rootPath));
        if (childApiFolders.length > 0) {
            utils_1.logger.silly(`Found (${childApiFolders.length}) api folders under the app folder`);
            utils_1.logger.silly(`- ${childApiFolders.map((f) => `${f.rootPath} (${f.frameworks.map((fr) => fr.name).join(", ")})`).join("\n- ")}`);
            detectedFolders.api = childApiFolders;
        }
    }
    if (detectedFolders.api.length > 1) {
        utils_1.logger.silly(`More than one (${detectedFolders.api.length}) api folders found`);
        const response = await (0, prompts_1.promptOrUseDefault)(disablePrompts, {
            type: "select",
            name: "api",
            message: "Which api folder do you want to use?",
            choices: detectedFolders.api.map((folder) => ({ title: folder.rootPath, value: folder })),
            initial: 0,
        });
        // Workaround for bug https://github.com/terkelg/prompts/issues/205
        api = typeof response.api === "number" ? detectedFolders.api[response.api] : response.api;
    }
    else {
        api = detectedFolders.api[0];
    }
    let projectConfig;
    try {
        projectConfig = await (0, frameworks_1.generateConfiguration)(app, api);
    }
    catch (error) {
        utils_1.logger.error(`Cannot generate your project configuration:`);
        utils_1.logger.error(error, true);
        return;
    }
    printFrameworkConfig(projectConfig);
    const { confirmSettings } = await (0, prompts_1.promptOrUseDefault)(disablePrompts, {
        type: "confirm",
        name: "confirmSettings",
        message: "Are these settings correct?",
        initial: true,
    });
    if (!confirmSettings) {
        // Ask for each settings
        projectConfig = await promptConfigSettings(disablePrompts, projectConfig);
    }
    if ((0, utils_1.swaCliConfigFileExists)(configFilePath) && (await (0, utils_1.hasConfigurationNameInConfigFile)(configFilePath, configName))) {
        const { confirmOverwrite } = await (0, prompts_1.promptOrUseDefault)(disablePrompts, {
            type: "confirm",
            name: "confirmOverwrite",
            message: `Configuration with name "${configName}" already exists, overwrite?`,
            initial: true,
        });
        if (!confirmOverwrite) {
            utils_1.logger.log("Aborted, configuration not saved.");
            return;
        }
    }
    const cliConfig = convertToCliConfig(projectConfig);
    await (0, utils_1.writeConfigFile)(configFilePath, configName, cliConfig);
    utils_1.logger.log(chalk_1.default.green(`\nConfiguration successfully saved to ${utils_1.swaCliConfigFilename}.\n`));
    if (showHints) {
        utils_1.logger.log(chalk_1.default.bold(`Get started with the following commands:`));
        utils_1.logger.log(`- Use ${chalk_1.default.cyan("swa start")} to run your app locally.`);
        if (cliConfig.appBuildCommand || cliConfig.apiBuildCommand) {
            utils_1.logger.log(`- Use ${chalk_1.default.cyan("swa build")} to build your app.`);
        }
        utils_1.logger.log(`- Use ${chalk_1.default.cyan("swa deploy")} to deploy your app to Azure.\n`);
    }
}
exports.init = init;
function convertToCliConfig(config) {
    return {
        appLocation: config.appLocation,
        apiLocation: config.apiLocation,
        outputLocation: config.outputLocation,
        appBuildCommand: config.appBuildCommand,
        apiBuildCommand: config.apiBuildCommand,
        run: config.appDevserverCommand,
        appDevserverUrl: config.appDevserverUrl,
    };
}
async function promptConfigSettings(disablePrompts, detectedConfig) {
    const trimValue = (value) => {
        value = value.trim();
        return value === "" ? undefined : value;
    };
    const response = await (0, prompts_1.promptOrUseDefault)(disablePrompts, [
        {
            type: "text",
            name: "appLocation",
            message: "What's your app location?",
            initial: detectedConfig.appLocation,
            validate: (value) => value.trim() !== "" || "App location cannot be empty",
            format: trimValue,
        },
        {
            type: "text",
            name: "outputLocation",
            message: "What's your build output location?",
            hint: "If your app doesn't have a build process, use the same location as your app",
            initial: detectedConfig.outputLocation,
            validate: (value) => value.trim() !== "" || "Output location cannot be empty",
            format: trimValue,
        },
        {
            type: "text",
            name: "apiLocation",
            message: "What's your API location? (optional)",
            initial: detectedConfig.apiLocation,
            format: trimValue,
        },
        {
            type: "text",
            name: "appBuildCommand",
            message: "What command do you use to build your app? (optional)",
            initial: detectedConfig.appBuildCommand,
            format: trimValue,
        },
        {
            type: "text",
            name: "apiBuildCommand",
            message: "What command do you use to build your API? (optional)",
            initial: detectedConfig.apiBuildCommand,
            format: trimValue,
        },
        {
            type: "text",
            name: "appDevserverCommand",
            message: "What command do you use to run your app for development? (optional)",
            initial: detectedConfig.appDevserverCommand,
            format: trimValue,
        },
        {
            type: "text",
            name: "appDevserverUrl",
            message: "What is your development server url (optional)",
            initial: detectedConfig.appDevserverUrl,
            format: trimValue,
        },
    ]);
    return response;
}
function printFrameworkConfig(config) {
    var _a, _b, _c, _d, _e, _f;
    utils_1.logger.log(chalk_1.default.bold("\nDetected configuration for your app:"));
    utils_1.logger.log(`- Framework(s): ${chalk_1.default.green((_a = config.name) !== null && _a !== void 0 ? _a : "none")}`);
    utils_1.logger.log(`- App location: ${chalk_1.default.green(config.appLocation)}`);
    utils_1.logger.log(`- Output location: ${chalk_1.default.green(config.outputLocation)}`);
    utils_1.logger.log(`- API location: ${chalk_1.default.green((_b = config.apiLocation) !== null && _b !== void 0 ? _b : "")}`);
    utils_1.logger.log(`- App build command: ${chalk_1.default.green((_c = config.appBuildCommand) !== null && _c !== void 0 ? _c : "")}`);
    utils_1.logger.log(`- API build command: ${chalk_1.default.green((_d = config.apiBuildCommand) !== null && _d !== void 0 ? _d : "")}`);
    utils_1.logger.log(`- App dev server command: ${chalk_1.default.green((_e = config.appDevserverCommand) !== null && _e !== void 0 ? _e : "")}`);
    utils_1.logger.log(`- App dev server URL: ${chalk_1.default.green((_f = config.appDevserverUrl) !== null && _f !== void 0 ? _f : "")}\n`);
}
// function isEmptyFolder(path: string) {
//   const files = fs.readdirSync(path);
//   return files.length === 0;
// }
//# sourceMappingURL=init.js.map