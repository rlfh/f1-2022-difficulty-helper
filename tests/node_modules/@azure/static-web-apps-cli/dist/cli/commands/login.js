"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.login = exports.addSharedLoginOptionsToCommand = void 0;
const chalk_1 = __importDefault(require("chalk"));
const dotenv_1 = __importDefault(require("dotenv"));
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const config_1 = require("../../config");
const core_1 = require("../../core");
const account_1 = require("../../core/account");
const constants_1 = require("../../core/constants");
const git_1 = require("../../core/git");
const prompts_1 = require("../../core/prompts");
const { readFile, writeFile } = fs_1.promises;
function addSharedLoginOptionsToCommand(command) {
    command
        .option("-S, --subscription-id <subscriptionId>", "Azure subscription ID used by this project", config_1.DEFAULT_CONFIG.subscriptionId)
        .option("-R, --resource-group <resourceGroupName>", "Azure resource group used by this project", config_1.DEFAULT_CONFIG.resourceGroupName)
        .option("-T, --tenant-id <tenantId>", "Azure tenant ID", config_1.DEFAULT_CONFIG.tenantId)
        .option("-C, --client-id <clientId>", "Azure client ID", config_1.DEFAULT_CONFIG.clientId)
        .option("-CS, --client-secret <clientSecret>", "Azure client secret", config_1.DEFAULT_CONFIG.clientSecret)
        .option("-n, --app-name <appName>", "Azure Static Web App application name", config_1.DEFAULT_CONFIG.appName)
        .option("-cc, --clear-credentials", "clear persisted credentials before login", config_1.DEFAULT_CONFIG.clearCredentials)
        .option("-u, --use-keychain", "enable using the operating system native keychain for persistent credentials", config_1.DEFAULT_CONFIG.useKeychain)
        // Note: Commander does not automatically recognize the --no-* option, so we have to explicitly use --no-use-keychain- instead
        .option("-nu, --no-use-keychain", "disable using the operating system native keychain", !config_1.DEFAULT_CONFIG.useKeychain);
}
exports.addSharedLoginOptionsToCommand = addSharedLoginOptionsToCommand;
function registerCommand(program) {
    const loginCommand = program
        .command("login")
        .usage("[options]")
        .description("login into Azure")
        .action(async (_options, command) => {
        const options = await (0, core_1.configureOptions)(undefined, command.optsWithGlobals(), command, "login");
        try {
            const { credentialChain, subscriptionId } = await login(options);
            if (credentialChain && subscriptionId) {
                core_1.logger.log(chalk_1.default.green(`✔ Successfully setup project!`));
            }
            else {
                core_1.logger.log(chalk_1.default.red(`✘ Failed to setup project!`));
                (0, core_1.logGiHubIssueMessageAndExit)();
            }
        }
        catch (error) {
            core_1.logger.error(`Failed to setup project: ${error.message}`);
            (0, core_1.logGiHubIssueMessageAndExit)();
        }
    })
        .addHelpText("after", `
Examples:

  Interactive login
  swa login

  Interactive login without persisting credentials
  swa login --no-use-keychain

  Log in into specific tenant
  swa login --tenant-id 00000000-0000-0000-0000-000000000000

  Log in using a specific subscription, resource group or an application
  swa login --subscription-id my-subscription \\
            --resource-group my-resource-group \\
            --app-name my-static-site

  Login using service principal
  swa login --tenant-id 00000000-0000-0000-0000-000000000000 \\
            --client-id 00000000-0000-0000-0000-000000000000 \\
            --client-secret 0000000000000000000000000000000000000000000000000000000000000000
    `);
    addSharedLoginOptionsToCommand(loginCommand);
}
exports.default = registerCommand;
async function login(options) {
    let credentialChain = undefined;
    core_1.logger.log(`Checking Azure session...`);
    let tenantId = options.tenantId;
    let clientId = options.clientId;
    let clientSecret = options.clientSecret;
    credentialChain = await (0, account_1.authenticateWithAzureIdentity)({ tenantId, clientId, clientSecret }, options.useKeychain, options.clearCredentials);
    if (await credentialChain.getToken("profile")) {
        core_1.logger.log(chalk_1.default.green(`✔ Successfully logged into Azure!`));
    }
    return await setupProjectCredentials(options, credentialChain);
}
exports.login = login;
async function setupProjectCredentials(options, credentialChain) {
    let { subscriptionId, tenantId, clientId, clientSecret } = options;
    // If the user has not specified a tenantId, we will prompt them to choose one
    if (!tenantId) {
        const tenants = await (0, account_1.listTenants)(credentialChain);
        if (tenants.length === 0) {
            throw new Error(`No Azure tenants found in your account.\n  Please read https://docs.microsoft.com/azure/cost-management-billing/manage/troubleshoot-sign-in-issue`);
        }
        else if (tenants.length === 1) {
            core_1.logger.silly(`Found 1 tenant: ${tenants[0].tenantId}`);
            tenantId = tenants[0].tenantId;
        }
        else {
            const tenant = await (0, prompts_1.chooseTenant)(tenants, options.tenantId);
            tenantId = tenant === null || tenant === void 0 ? void 0 : tenant.tenantId;
            // login again with the new tenant
            // TODO: can we silently authenticate the user with the new tenant?
            credentialChain = await (0, account_1.authenticateWithAzureIdentity)({ tenantId, clientId, clientSecret }, options.useKeychain, true);
            if (await credentialChain.getToken("profile")) {
                core_1.logger.log(chalk_1.default.green(`✔ Successfully logged into Azure tenant: ${tenantId}`));
            }
        }
    }
    core_1.logger.silly(`Selected tenant: ${tenantId}`);
    // If the user has not specified a subscriptionId, we will prompt them to choose one
    if (!subscriptionId) {
        const subscriptions = await (0, account_1.listSubscriptions)(credentialChain);
        if (subscriptions.length === 0) {
            throw new Error(`No valid subscription found for tenant ${tenantId}.\n  Please read https://docs.microsoft.com/azure/cost-management-billing/manage/no-subscriptions-found`);
        }
        else if (subscriptions.length === 1) {
            core_1.logger.silly(`Found 1 subscription: ${subscriptions[0].subscriptionId}`);
            subscriptionId = subscriptions[0].subscriptionId;
        }
        else {
            const subscription = await (0, prompts_1.chooseSubscription)(subscriptions, subscriptionId);
            subscriptionId = subscription === null || subscription === void 0 ? void 0 : subscription.subscriptionId;
        }
    }
    core_1.logger.silly(`Selected subscription: ${subscriptionId}`);
    core_1.logger.silly(`Project credentials:`);
    core_1.logger.silly({ subscriptionId, tenantId, clientId, clientSecret });
    await storeProjectCredentialsInEnvFile(subscriptionId, tenantId, clientId, clientSecret);
    return {
        credentialChain,
        subscriptionId: subscriptionId,
    };
}
async function storeProjectCredentialsInEnvFile(subscriptionId, tenantId, clientId, clientSecret) {
    const envFile = path_1.default.join(process.cwd(), constants_1.ENV_FILENAME);
    const envFileExists = (0, fs_1.existsSync)(envFile);
    const envFileContent = envFileExists ? await readFile(envFile, "utf8") : "";
    const buf = Buffer.from(envFileContent);
    // in case the .env file format changes in the future, we can use the following to parse the file
    const config = dotenv_1.default.parse(buf);
    const oldEnvFileLines = Object.keys(config).map((key) => `${key}=${config[key]}`);
    const newEnvFileLines = [];
    let entry = `AZURE_SUBSCRIPTION_ID=${subscriptionId}`;
    if (subscriptionId && !envFileContent.includes(entry)) {
        newEnvFileLines.push(entry);
    }
    entry = `AZURE_TENANT_ID=${tenantId}`;
    if (tenantId && !envFileContent.includes(entry)) {
        newEnvFileLines.push(entry);
    }
    entry = `AZURE_CLIENT_ID=${clientId}`;
    if (clientId && !envFileContent.includes(entry)) {
        newEnvFileLines.push(entry);
    }
    entry = `AZURE_CLIENT_SECRET=${clientSecret}`;
    if (clientSecret && !envFileContent.includes(entry)) {
        newEnvFileLines.push(entry);
    }
    // write file if we have at least one new env line
    if (newEnvFileLines.length > 0) {
        const envFileContentWithProjectDetails = [...oldEnvFileLines, ...newEnvFileLines].join("\n");
        await writeFile(envFile, envFileContentWithProjectDetails);
        core_1.logger.log(chalk_1.default.green(`✔ Saved project credentials in ${constants_1.ENV_FILENAME} file.`));
        await (0, git_1.updateGitIgnore)(constants_1.ENV_FILENAME);
    }
}
//# sourceMappingURL=login.js.map