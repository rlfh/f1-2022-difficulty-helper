"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.build = void 0;
const path_1 = __importDefault(require("path"));
const chalk_1 = __importDefault(require("chalk"));
const config_1 = require("../../config");
const frameworks_1 = require("../../core/frameworks");
const utils_1 = require("../../core/utils");
function registerCommand(program) {
    program
        .command("build [configName|appLocation]")
        .usage("[configName|appLocation] [options]")
        .description("build your project")
        .option("-a, --app-location <path>", "the folder containing the source code of the front-end application", config_1.DEFAULT_CONFIG.appLocation)
        .option("-i, --api-location <path>", "the folder containing the source code of the API application", config_1.DEFAULT_CONFIG.apiLocation)
        .option("-O, --output-location <path>", "the folder containing the built source of the front-end application", config_1.DEFAULT_CONFIG.outputLocation)
        .option("-A, --app-build-command <command>", "the command used to build your app", config_1.DEFAULT_CONFIG.appBuildCommand)
        .option("-I, --api-build-command <command>", "the command used to build your api", config_1.DEFAULT_CONFIG.apiBuildCommand)
        .option("--auto", "automatically detect how to build your app and api", false)
        .action(async (positionalArg, _options, command) => {
        const options = await (0, utils_1.configureOptions)(positionalArg, command.optsWithGlobals(), command, "build");
        if (positionalArg && !(0, utils_1.matchLoadedConfigName)(positionalArg)) {
            if ((0, utils_1.isUserOption)("appLocation")) {
                utils_1.logger.error(`swa build <appLocation> cannot be when with --app-location option is also set.`);
                utils_1.logger.error(`You either have to use the positional argument or option, not both at the same time.`, true);
            }
            // If it's not the config name, then it's the app location
            options.appLocation = positionalArg;
        }
        await build(options);
    });
}
exports.default = registerCommand;
async function build(options) {
    var _a, _b, _c, _d, _e;
    const workflowConfig = (0, utils_1.readWorkflowFile)();
    utils_1.logger.silly({
        workflowConfig,
        options: {
            appLocation: options.appLocation,
            apiLocation: options.apiLocation,
            outputLocation: options.outputLocation,
            appBuildCommand: options.appBuildCommand,
            apiBuildCommand: options.apiBuildCommand,
        },
    });
    let appLocation = (_a = options.appLocation) !== null && _a !== void 0 ? _a : workflowConfig === null || workflowConfig === void 0 ? void 0 : workflowConfig.appLocation;
    let apiLocation = (_b = options.apiLocation) !== null && _b !== void 0 ? _b : workflowConfig === null || workflowConfig === void 0 ? void 0 : workflowConfig.apiLocation;
    let outputLocation = (_c = options.outputLocation) !== null && _c !== void 0 ? _c : workflowConfig === null || workflowConfig === void 0 ? void 0 : workflowConfig.outputLocation;
    let appBuildCommand = (_d = options.appBuildCommand) !== null && _d !== void 0 ? _d : workflowConfig === null || workflowConfig === void 0 ? void 0 : workflowConfig.appBuildCommand;
    let apiBuildCommand = (_e = options.apiBuildCommand) !== null && _e !== void 0 ? _e : workflowConfig === null || workflowConfig === void 0 ? void 0 : workflowConfig.apiBuildCommand;
    if (options.auto && hasBuildOptionsDefined(options)) {
        utils_1.logger.error(`You can't use the --auto option when you have defined appBuildCommand or apiBuildCommand in ${utils_1.swaCliConfigFilename}`);
        utils_1.logger.error(`or with the --app-build-command and --api-build-command options.`, true);
        return;
    }
    if (options.auto) {
        utils_1.logger.log("Detecting build configuration...");
        const detectedFolders = await (0, frameworks_1.detectProjectFolders)(appLocation);
        if (detectedFolders.app.length === 0 && detectedFolders.api.length === 0) {
            utils_1.logger.error(`Your app configuration could not be detected.`);
            return showAutoErrorMessageAndExit();
        }
        else if (detectedFolders.app.length > 1 || detectedFolders.api.length > 1) {
            utils_1.logger.error(`Multiple apps found in your project folder.`);
            return showAutoErrorMessageAndExit();
        }
        let projectConfig;
        try {
            projectConfig = await (0, frameworks_1.generateConfiguration)(detectedFolders.app[0], detectedFolders.api[0]);
            appLocation = projectConfig.appLocation;
            apiLocation = projectConfig.apiLocation;
            outputLocation = projectConfig.outputLocation;
            apiBuildCommand = projectConfig.apiBuildCommand;
            appBuildCommand = projectConfig.appBuildCommand;
        }
        catch (error) {
            utils_1.logger.error(`Cannot generate your build configuration:`);
            utils_1.logger.error(error, true);
            return;
        }
    }
    if (!appBuildCommand && !apiBuildCommand) {
        if (!hasBuildOptionsDefined(options)) {
            utils_1.logger.warn("No build options were defined.");
            utils_1.logger.warn('If your app needs a build step, run "swa init" to set your project configuration');
            utils_1.logger.warn(`or use option flags to set your build commands and paths.\n`);
        }
        utils_1.logger.log("Nothing to build.");
        return;
    }
    utils_1.logger.log(`Build configuration:`);
    utils_1.logger.log(`- App location: ${chalk_1.default.green(appLocation || "")}`);
    utils_1.logger.log(`- API location: ${chalk_1.default.green(apiLocation || "")}`);
    utils_1.logger.log(`- Output location: ${chalk_1.default.green(outputLocation || "")}`);
    utils_1.logger.log(`- App build command: ${chalk_1.default.green(appBuildCommand || "")}`);
    utils_1.logger.log(`- API build command: ${chalk_1.default.green(apiBuildCommand || "")}`);
    if (appBuildCommand) {
        const packageJsonPath = await (0, utils_1.findUpPackageJsonDir)(appLocation, outputLocation);
        if (packageJsonPath) {
            utils_1.logger.log(`Found package.json in ${packageJsonPath}`);
            await installNpmDependencies(packageJsonPath);
        }
        utils_1.logger.log(`Building app with ${chalk_1.default.green(appBuildCommand)} in ${chalk_1.default.dim(appLocation)} ...`);
        (0, utils_1.runCommand)(appBuildCommand, appLocation);
    }
    if (apiBuildCommand) {
        // For now, only look up in the api location as there's no equivalent to outputLocation for api
        const packageJsonPath = await (0, utils_1.findUpPackageJsonDir)(apiLocation, ".");
        if (packageJsonPath) {
            utils_1.logger.log(`Found package.json in ${packageJsonPath}`);
            await installNpmDependencies(packageJsonPath);
        }
        utils_1.logger.log(`Building api with ${chalk_1.default.green(apiBuildCommand)} in ${chalk_1.default.dim(apiLocation)} ...`);
        (0, utils_1.runCommand)(apiBuildCommand, apiLocation);
    }
}
exports.build = build;
function hasBuildOptionsDefined(options) {
    if (options.appBuildCommand || options.apiBuildCommand) {
        return true;
    }
    return (0, utils_1.isUserOrConfigOption)("appBuildCommand") || (0, utils_1.isUserOrConfigOption)("apiBuildCommand");
}
function showAutoErrorMessageAndExit() {
    utils_1.logger.error(`Please run "swa init" to set your configuration or use option flags to set your`);
    utils_1.logger.error(`build commands and paths.`, true);
}
async function detectPackageManager(basePath) {
    const hasYarnLock = await (0, utils_1.pathExists)(path_1.default.join(basePath, "yarn.lock"));
    const hasNpmLock = await (0, utils_1.pathExists)(path_1.default.join(basePath, "package-lock.json"));
    const hasPnpmLock = await (0, utils_1.pathExists)(path_1.default.join(basePath, "pnpm-lock.yaml"));
    if (hasPnpmLock && !hasNpmLock && !hasYarnLock) {
        return "pnpm";
    }
    if (hasYarnLock && !hasNpmLock) {
        return "yarn";
    }
    return "npm";
}
async function installNpmDependencies(packageJsonPath) {
    try {
        const packageManager = await detectPackageManager(packageJsonPath);
        utils_1.logger.log(`Installing dependencies with "${packageManager} install"...`);
        (0, utils_1.runCommand)(`${packageManager} install`, packageJsonPath);
    }
    catch (error) {
        utils_1.logger.error(`Cannot install dependencies:`);
        utils_1.logger.error(error, true);
    }
}
//# sourceMappingURL=build.js.map