"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deploy = void 0;
const chalk_1 = __importDefault(require("chalk"));
const child_process_1 = require("child_process");
const fs_1 = __importDefault(require("fs"));
const ora_1 = __importDefault(require("ora"));
const path_1 = __importDefault(require("path"));
const config_1 = require("../../config");
const core_1 = require("../../core");
const account_1 = require("../../core/account");
const deploy_client_1 = require("../../core/deploy-client");
const env_1 = require("../../core/env");
const login_1 = require("./login");
const packageInfo = require(path_1.default.join(__dirname, "..", "..", "..", "package.json"));
function registerCommand(program) {
    const deployCommand = program
        .command("deploy [configName|outputLocation]")
        .usage("[configName|outputLocation] [options]")
        .description("deploy the current project to Azure Static Web Apps")
        .option("-a, --app-location <path>", "the folder containing the source code of the front-end application", config_1.DEFAULT_CONFIG.appLocation)
        .option("-i, --api-location <path>", "the folder containing the source code of the API application", config_1.DEFAULT_CONFIG.apiLocation)
        .option("-O, --output-location <path>", "the folder containing the built source of the front-end application", config_1.DEFAULT_CONFIG.outputLocation)
        .option("-w, --swa-config-location <swaConfigLocation>", "the directory where the staticwebapp.config.json file is located", config_1.DEFAULT_CONFIG.swaConfigLocation)
        .option("-d, --deployment-token <secret>", "the secret token used to authenticate with the Static Web Apps")
        .option("-dr, --dry-run", "simulate a deploy process without actually running it", config_1.DEFAULT_CONFIG.dryRun)
        .option("-pt, --print-token", "print the deployment token", false)
        .option("--env [environment]", "the type of deployment environment where to deploy the project", config_1.DEFAULT_CONFIG.env)
        .action(async (positionalArg, _options, command) => {
        const options = await (0, core_1.configureOptions)(positionalArg, command.optsWithGlobals(), command, "deploy");
        if (positionalArg && !(0, core_1.matchLoadedConfigName)(positionalArg)) {
            if ((0, core_1.isUserOption)("outputLocation")) {
                core_1.logger.error(`swa deploy <outputLocation> cannot be used when --output-location option is also set.`);
                core_1.logger.error(`You either have to use the positional argument or option, not both at the same time.`, true);
            }
            // If it's not the config name, then it's the output location
            options.outputLocation = positionalArg;
        }
        await deploy(options);
    })
        .addHelpText("after", `
Examples:

  Deploy using a deployment token
  swa deploy ./dist/ --api-location ./api/ --deployment-token <token>

  Deploy using a deployment token from env
  SWA_CLI_DEPLOYMENT_TOKEN=123 swa deploy ./dist/ --api-location ./api/

  Deploy using swa-cli.config.json file
  swa deploy
  swa deploy myconfig

  Print the deployment token
  swa deploy --print-token

  Deploy to a specific environment
  swa deploy --env production
    `);
    (0, login_1.addSharedLoginOptionsToCommand)(deployCommand);
}
exports.default = registerCommand;
async function deploy(options) {
    var _a, _b, _c, _d, _e;
    const { SWA_CLI_DEPLOYMENT_TOKEN, SWA_CLI_DEBUG } = (0, env_1.swaCLIEnv)();
    const isVerboseEnabled = SWA_CLI_DEBUG === "silly";
    let { appLocation, apiLocation, outputLocation, dryRun, deploymentToken, printToken, appName, swaConfigLocation, verbose } = options;
    if (dryRun) {
        core_1.logger.warn("***********************************************************************");
        core_1.logger.warn("* WARNING: Running in dry run mode. This project will not be deployed *");
        core_1.logger.warn("***********************************************************************");
        core_1.logger.warn("");
    }
    // make sure appLocation is set
    appLocation = path_1.default.resolve(appLocation || process.cwd());
    // make sure outputLocation is set
    const resolvedOutputLocation = path_1.default.resolve(appLocation, outputLocation || process.cwd());
    // if folder exists, deploy from a specific build folder (outputLocation), relative to appLocation
    if (!fs_1.default.existsSync(resolvedOutputLocation)) {
        core_1.logger.error(`The folder "${resolvedOutputLocation}" is not found. Exit.`, true);
        return;
    }
    core_1.logger.log(`Deploying front-end files from folder:`);
    core_1.logger.log(`  ${chalk_1.default.green(resolvedOutputLocation)}`);
    core_1.logger.log(``);
    // if --api-location is provided, use it as the api folder
    let resolvedApiLocation = undefined;
    if (apiLocation) {
        resolvedApiLocation = path_1.default.resolve(apiLocation);
        if (!fs_1.default.existsSync(resolvedApiLocation)) {
            core_1.logger.error(`The provided API folder ${resolvedApiLocation} does not exist. Abort.`, true);
            return;
        }
        else {
            core_1.logger.log(`Deploying API from folder:`);
            core_1.logger.log(`  ${chalk_1.default.green(resolvedApiLocation)}`);
            core_1.logger.log(``);
        }
    }
    else {
        // otherwise, check if the default api folder exists and print a warning
        const apiFolder = await findApiFolderInPath(appLocation);
        if (apiFolder) {
            core_1.logger.warn(`An API folder was found at ".${path_1.default.sep + path_1.default.basename(apiFolder)}" but the --api-location option was not provided. The API will not be deployed.\n`);
        }
    }
    // resolve the deployment token
    if (deploymentToken) {
        deploymentToken = deploymentToken;
        core_1.logger.silly("Deployment token provided via flag");
        core_1.logger.silly({ [chalk_1.default.green(`--deployment-token`)]: deploymentToken });
    }
    else if (SWA_CLI_DEPLOYMENT_TOKEN) {
        deploymentToken = SWA_CLI_DEPLOYMENT_TOKEN;
        core_1.logger.silly("Deployment token found in Environment Variables:");
        core_1.logger.silly({ [chalk_1.default.green(`SWA_CLI_DEPLOYMENT_TOKEN`)]: SWA_CLI_DEPLOYMENT_TOKEN });
    }
    else if (dryRun === false) {
        core_1.logger.silly(`No deployment token found. Trying interactive login...`);
        try {
            const { credentialChain, subscriptionId } = await (0, login_1.login)({
                ...options,
            });
            core_1.logger.silly(`Login successful`);
            if (appName) {
                core_1.logger.log(`\nChecking project "${appName}" settings...`);
            }
            else {
                core_1.logger.log(`\nChecking project settings...`);
            }
            const { resourceGroupName, staticSiteName } = (await (0, account_1.chooseOrCreateProjectDetails)(options, credentialChain, subscriptionId, printToken));
            core_1.logger.silly(`Project settings:`);
            core_1.logger.silly({
                resourceGroupName,
                staticSiteName,
                subscriptionId,
            });
            const deploymentTokenResponse = await (0, account_1.getStaticSiteDeployment)(credentialChain, subscriptionId, resourceGroupName, staticSiteName);
            deploymentToken = (_a = deploymentTokenResponse === null || deploymentTokenResponse === void 0 ? void 0 : deploymentTokenResponse.properties) === null || _a === void 0 ? void 0 : _a.apiKey;
            if (!deploymentToken) {
                core_1.logger.error("Cannot find a deployment token. Aborting.", true);
            }
            else {
                core_1.logger.log(chalk_1.default.green(`âœ” Successfully setup project!`));
                // store project settings in swa-cli.config.json (if available)
                if (dryRun === false) {
                    const currentSwaCliConfig = (0, core_1.getCurrentSwaCliConfigFromFile)();
                    if (currentSwaCliConfig === null || currentSwaCliConfig === void 0 ? void 0 : currentSwaCliConfig.config) {
                        core_1.logger.silly(`Saving project settings to swa-cli.config.json...`);
                        const newConfig = { ...currentSwaCliConfig === null || currentSwaCliConfig === void 0 ? void 0 : currentSwaCliConfig.config };
                        newConfig.appName = staticSiteName;
                        newConfig.resourceGroupName = resourceGroupName;
                        (0, core_1.updateSwaCliConfigFile)(newConfig);
                    }
                    else {
                        core_1.logger.silly(`No swa-cli.config.json file found. Skipping saving project settings.`);
                    }
                }
                core_1.logger.silly("\nDeployment token provided via remote configuration");
                core_1.logger.silly({ [chalk_1.default.green(`deploymentToken`)]: deploymentToken });
            }
        }
        catch (error) {
            core_1.logger.error(error.message);
            return;
        }
    }
    core_1.logger.log(`\nDeploying to environment: ${chalk_1.default.green(options.env)}\n`);
    if (printToken) {
        core_1.logger.log(`Deployment token:`);
        core_1.logger.log(chalk_1.default.green(deploymentToken));
        process.exit(0);
    }
    // TODO: do that in options
    // mix CLI args with the project's build workflow configuration (if any)
    // use any specific workflow config that the user might provide undef ".github/workflows/"
    // Note: CLI args will take precedence over workflow config
    let userWorkflowConfig = {
        appLocation,
        outputLocation: resolvedOutputLocation,
        apiLocation: resolvedApiLocation,
    };
    try {
        userWorkflowConfig = (0, core_1.readWorkflowFile)({
            userWorkflowConfig,
        });
    }
    catch (err) {
        core_1.logger.warn(``);
        core_1.logger.warn(`Error reading workflow configuration:`);
        core_1.logger.warn(err.message);
        core_1.logger.warn(`See https://docs.microsoft.com/azure/static-web-apps/build-configuration?tabs=github-actions#build-configuration for more information.`);
    }
    swaConfigLocation = swaConfigLocation || (userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.appLocation);
    const swaConfigFilePath = (_b = (await (0, core_1.findSWAConfigFile)(swaConfigLocation))) === null || _b === void 0 ? void 0 : _b.filepath;
    const resolvedSwaConfigLocation = swaConfigFilePath ? path_1.default.dirname(swaConfigFilePath) : undefined;
    const cliEnv = {
        SWA_CLI_DEBUG: verbose,
        SWA_RUNTIME_WORKFLOW_LOCATION: (_c = userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.files) === null || _c === void 0 ? void 0 : _c[0],
        SWA_RUNTIME_CONFIG_LOCATION: resolvedSwaConfigLocation,
        SWA_RUNTIME_CONFIG: swaConfigFilePath,
        SWA_CLI_VERSION: packageInfo.version,
        SWA_CLI_DEPLOY_DRY_RUN: `${dryRun}`,
        SWA_CLI_DEPLOY_BINARY: undefined,
    };
    const deployClientEnv = {
        DEPLOYMENT_ACTION: options.dryRun ? "close" : "upload",
        DEPLOYMENT_PROVIDER: `swa-cli-${packageInfo.version}`,
        REPOSITORY_BASE: userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.appLocation,
        SKIP_APP_BUILD: "true",
        SKIP_API_BUILD: "true",
        DEPLOYMENT_TOKEN: deploymentToken,
        // /!\ Static site client doesn't use OUTPUT_LOCATION at all if SKIP_APP_BUILD is set,
        // so you need to provide the output path as the app location
        APP_LOCATION: userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.outputLocation,
        // OUTPUT_LOCATION: outputLocation,
        API_LOCATION: userWorkflowConfig === null || userWorkflowConfig === void 0 ? void 0 : userWorkflowConfig.apiLocation,
        // If config file is not in output location, we need to tell where to find it
        CONFIG_FILE_LOCATION: resolvedSwaConfigLocation,
        VERBOSE: isVerboseEnabled ? "true" : "false",
    };
    // set the DEPLOYMENT_ENVIRONMENT env variable only when the user has provided
    // a deployment environment which is not "production".
    if (((_d = options.env) === null || _d === void 0 ? void 0 : _d.toLowerCase()) !== "production" && ((_e = options.env) === null || _e === void 0 ? void 0 : _e.toLowerCase()) !== "prod") {
        deployClientEnv.DEPLOYMENT_ENVIRONMENT = options.env;
    }
    core_1.logger.log(`Deploying project to Azure Static Web Apps...`);
    let spinner = {};
    try {
        const { binary, buildId } = await (0, deploy_client_1.getDeployClientPath)();
        if (binary) {
            spinner = (0, ora_1.default)();
            cliEnv.SWA_CLI_DEPLOY_BINARY = `${binary}@${buildId}`;
            spinner.text = `Deploying using ${cliEnv.SWA_CLI_DEPLOY_BINARY}`;
            core_1.logger.silly(`Deploying using ${cliEnv.SWA_CLI_DEPLOY_BINARY}`);
            core_1.logger.silly(`Deploying using the following options:`);
            core_1.logger.silly({ env: { ...cliEnv, ...deployClientEnv } });
            spinner.start(`Preparing deployment. Please wait...`);
            const child = (0, child_process_1.spawn)(binary, [], {
                env: {
                    ...(0, env_1.swaCLIEnv)(cliEnv, deployClientEnv),
                },
            });
            let projectUrl = "";
            child.stdout.on("data", (data) => {
                data
                    .toString()
                    .trim()
                    .split("\n")
                    .forEach((line) => {
                    var _a, _b;
                    if (line.includes("Exiting")) {
                        spinner.text = line;
                        spinner.stop();
                    }
                    else if (line.includes("Visit your site at:")) {
                        projectUrl = (_b = (_a = line.match("http.*")) === null || _a === void 0 ? void 0 : _a.pop()) === null || _b === void 0 ? void 0 : _b.trim();
                        line = "";
                    }
                    // catch errors printed to stdout
                    else if (line.includes("[31m")) {
                        if (line.includes("Cannot deploy to the function app because Function language info isn't provided.")) {
                            line = chalk_1.default.red(`Cannot deploy to the function app because Function language info isn't provided. Add a "platform.apiRuntime" property to your staticwebapp.config.json file, or create one in ${options.outputLocation}. Please consult the documentation for more information about staticwebapp.config.json: https://docs.microsoft.com/azure/static-web-apps/configuration`);
                        }
                        spinner.fail(chalk_1.default.red(line));
                    }
                    else {
                        if (isVerboseEnabled || dryRun) {
                            spinner.info(line.trim());
                        }
                        else {
                            spinner.text = line.trim();
                        }
                    }
                });
            });
            child.on("error", (error) => {
                core_1.logger.error(error.toString());
            });
            child.on("close", (code) => {
                (0, deploy_client_1.cleanUp)();
                if (code === 0) {
                    spinner.succeed(chalk_1.default.green(`Project deployed to ${chalk_1.default.underline(projectUrl)} ðŸš€`));
                    core_1.logger.log(``);
                }
            });
        }
    }
    catch (error) {
        core_1.logger.error("");
        core_1.logger.error("Deployment Failed :(");
        core_1.logger.error(`Deployment Failure Reason: ${error.message}`);
        core_1.logger.error(`For further information, please visit the Azure Static Web Apps documentation at https://docs.microsoft.com/azure/static-web-apps/`);
        (0, core_1.logGiHubIssueMessageAndExit)();
    }
    finally {
        (0, deploy_client_1.cleanUp)();
    }
}
exports.deploy = deploy;
async function findApiFolderInPath(appPath) {
    var _a;
    const entries = await fs_1.default.promises.readdir(appPath, { withFileTypes: true });
    return (_a = entries.find((entry) => entry.name.toLowerCase() === "api" && entry.isDirectory())) === null || _a === void 0 ? void 0 : _a.name;
}
//# sourceMappingURL=deploy.js.map